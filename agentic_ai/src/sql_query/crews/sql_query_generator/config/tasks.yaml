query_interpretation_task:
  description: >
    <Task>
      Convert natural language user requests into a clear,structured and logical query plan. 
    </Task>

    <Available Tools>
      You have access to these two tools:
      1. **SQLQueryTool**: For executing SQL queries against the database and the distinct values of a column for **IN** queries.
    </Available Tools>

    Today's date is {date}.

    <User Request>
    Here is the user's original request:
    {user_prompt}
    </User Request>

    <Column Description>
      You are provided with the column description of **projects_encoded** table:
      {column_description}
    </Column Description>

    <Previous Execution Error>
      {previous_error}
    </Previous Execution Error>

    <Audience>
      Your audience is a SQL query generator that will use your logical plan to create an accurate SQL query.
    </Audience>

    <Instructions>
      Think like a SQL query planner and break down the user's request into a series of logical steps that can be translated into SQL.

      If <PreviousError> is not None, consider why the previous execution failed and adjust your logical plan accordingly:
      
        - Avoid previous mistakes.
        - Add additional filters, clarify ambiguous fields, or restructure joins if needed.
        - Suggest alternative aggregations or columns if relevant.

      1. Analyze only data relevant to the user's request.
      2. Determine filters, aggregations, joins, groupings, and ordering.
      3. Whenever you are performing **IN** query on a column, query the column to find the distinct values first.  
      4. Resolve ambiguities using column descriptions and table purposes.
      5. Mark field as 'needs_clarification' if ambiguous.
    </Instructions>

    <Show Your Thinking>
      After analyzing the user's request, provide a detailed breakdown of the logical components needed to fulfill the request.
        - What tables did I identify as relevant?
        - What columns are necessary for selection or aggregation?
        - What's missing?
        - Do I have enough information to proceed?
        - Should I search for additional context?
    </Show Your Thinking>

    <Examples>
      Here are three examples of good logical query plans:

      **Example 1 (for "Vendors with the highest forecast transport delivery delays"):**
        {
          "tables": ["projects_encoded"],
          "columns": ["county"],
          "filters": [
            {
              "column": "real_estate_released_a",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "project_started_milestone_a",
              "operator": "IS NOT NULL",
              "value": null
            }
          ],
          "aggregations": [
            {
              "column": "TO_DATE(real_estate_released_a, 'YYYY-MM-DD') - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')",
              "type": "AVG",
              "alias": "avg_rer_duration"
            }
          ],
          "joins": [],
          "group_by": ["county"],
          "order_by": ["avg_rer_duration DESC"]
        }

      **Example 2 (for "Milestones forecasted to slip into next quarter (Q4 2025 example)")**
        {
          "tables": ["projects_encoded"],
          "columns": ["fuze_project_id", "site_name", "milestone", "forecast_date"],
          "filters": [
            {
              "column": "real_estate_released_f",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "real_estate_released_f",
              "operator": "BETWEEN",
              "value": ["2025-10-01", "2025-12-31"]
            }
          ],
          "unions": [
            {
              "columns": ["fuze_project_id", "site_name", "'Real Estate Released' AS milestone", "real_estate_released_f AS forecast_date"],
              "filters": [
                {
                  "column": "real_estate_released_f",
                  "operator": "IS NOT NULL",
                  "value": null
                },
                {
                  "column": "real_estate_released_f",
                  "operator": "BETWEEN",
                  "value": ["2025-10-01", "2025-12-31"]
                }
              ]
            },
            {
              "columns": ["fuze_project_id", "site_name", "'Zoning Approved' AS milestone", "zoning_approved_a AS forecast_date"],
              "filters": [
                {
                  "column": "zoning_approved_a",
                  "operator": "IS NOT NULL",
                  "value": null
                },
                {
                  "column": "zoning_approved_a",
                  "operator": "BETWEEN",
                  "value": ["2025-10-01", "2025-12-31"]
                }
              ]
            },
            {
              "columns": ["fuze_project_id", "site_name", "'Transport Delivery' AS milestone", "transport_delivery_completed_a AS forecast_date"],
              "filters": [
                {
                  "column": "transport_delivery_completed_a",
                  "operator": "IS NOT NULL",
                  "value": null
                },
                {
                  "column": "transport_delivery_completed_a",
                  "operator": "BETWEEN",
                  "value": ["2025-10-01", "2025-12-31"]
                }
              ]
            }
          ]
        }

      **Example 3 (for "Anomalies (extreme delays or missing milestones)")**
        {
          "tables": ["projects_encoded"],
          "columns": ["fuze_project_id", "site_name", "rer_duration", "anomaly_flag"],
          "filters": [
            {
              "column": "real_estate_released_a",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "project_started_milestone_a",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "rer_duration",
              "operator": "IS NULL OR > mean_dur + 2 * std_dur OR < mean_dur - 2 * std_dur",
              "value": null
            }
          ],
          "aggregations": [
            {
              "column": "TO_DATE(real_estate_released_a, 'YYYY-MM-DD') - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')",
              "type": "AVG",
              "alias": "mean_dur"
            },
            {
              "column": "TO_DATE(real_estate_released_a, 'YYYY-MM-DD') - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')",
              "type": "STDDEV",
              "alias": "std_dur"
            }
          ],
          "joins": [
            {
              "type": "CROSS",
              "table": "stats",
              "on": null
            }
          ],
          "case_statements": [
            {
              "column": "rer_duration",
              "cases": [
                {
                  "condition": "rer_duration > mean_dur + 2 * std_dur",
                  "value": "'Extreme Delay'"
                },
                {
                  "condition": "rer_duration < mean_dur - 2 * std_dur",
                  "value": "'Unusually Fast'"
                },
                {
                  "condition": "ELSE",
                  "value": "'Normal'"
                }
              ],
              "alias": "anomaly_flag"
            }
          ]
        }
    </Examples>
  expected_output: >
    <Output Format>
    {{
        "tables": "All the relevant tables needed for the query",
        "columns": "Specific columns to be selected or aggregated",
        "filters": "Conditions to filter the data",
        "aggregations": "Any aggregations needed (e.g., SUM, COUNT)",
        "joins": "Details of any joins between tables",
        "group_by": "Columns to group the results by",
        "order_by": "Columns to order the results by",
        "unions": "Details of any unions if applicable",
        "case_statements": "Details of any case statements if applicable",
    }}
    </Output Format>
  agent: query_interpretation_agent

query_generation_task:
  description: >
    <Task>
      Convert structured query plan into a syntatically correct, optimized Postgres SQL query.
    </Task>

    Today's date is {date}.

    <Instructions>
      Using the provided logical query plan, generate a syntactically correct and optimized SQL query that fulfills the user's request.
        1. Generate only one SQL query for the plan.
        2. Use explicit JOIN type (INNER, LEFT, RIGHT) as indicated in the plan.
        3. Apply all filters, aggregations, GROUP BY, and ORDER BY accurately.
        4. Optimize the query for performance without changing results.
        5. Return ONLY the SQL, nothing else.
        6. Ensure all identifiers match the database metadata exactly.
    <Instructions>

    <Examples>
      Here are two examples of good SQL queries based on logical plans:
      **Example 1**
        <Logical Query Input>
        {
          "tables": ["projects_encoded"],
          "columns": ["county"],
          "filters": [
            {
              "column": "real_estate_released_a",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "project_started_milestone_a",
              "operator": "IS NOT NULL",
              "value": null
            }
          ],
          "aggregations": [
            {
              "column": "TO_DATE(real_estate_released_a, 'YYYY-MM-DD') - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')",
              "type": "AVG",
              "alias": "avg_rer_duration"
            }
          ],
          "joins": [],
          "group_by": ["county"],
          "order_by": ["avg_rer_duration DESC"]
        }
        </Logical Query Input>

        <SQL Output>
          SELECT
          COALESCE(structure_owner, vendor_site_acquisition) AS responsible_party,
          COUNT(*) AS total_projects,
          AVG(TO_DATE(real_estate_released_a, 'YYYY-MM-DD')
              - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')) AS avg_delay
          FROM projects_encoded
          WHERE real_estate_released_a IS NOT NULL
            AND project_started_milestone_a IS NOT NULL
          GROUP BY responsible_party
          ORDER BY avg_delay DESC;
        </SQL Output>
    
      **Example 2**
        <Logical Query Input>
        {
          "tables": ["projects_encoded"],
          "columns": ["fuze_project_id", "site_name", "rer_duration", "anomaly_flag"],
          "filters": [
            {
              "column": "real_estate_released_a",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "project_started_milestone_a",
              "operator": "IS NOT NULL",
              "value": null
            },
            {
              "column": "rer_duration",
              "operator": "IS NULL OR > mean_dur + 2 * std_dur OR < mean_dur - 2 * std_dur",
              "value": null
            }
          ],
          "aggregations": [
            {
              "column": "TO_DATE(real_estate_released_a, 'YYYY-MM-DD') - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')",
              "type": "AVG",
              "alias": "mean_dur"
            },
            {
              "column": "TO_DATE(real_estate_released_a, 'YYYY-MM-DD') - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')",
              "type": "STDDEV",
              "alias": "std_dur"
            }
          ],
          "joins": [
            {
              "type": "CROSS",
              "table": "stats",
              "on": null
            }
          ],
          "case_statements": [
            {
              "column": "rer_duration",
              "cases": [
                {
                  "condition": "rer_duration > mean_dur + 2 * std_dur",
                  "value": "'Extreme Delay'"
                },
                {
                  "condition": "rer_duration < mean_dur - 2 * std_dur",
                  "value": "'Unusually Fast'"
                },
                {
                  "condition": "ELSE",
                  "value": "'Normal'"
                }
              ],
              "alias": "anomaly_flag"
            }
          ]
        }
        </Logical Query Input>

        <SQL Output>
          WITH durations AS (
          SELECT
              fuze_project_id,
              site_name,
              (TO_DATE(real_estate_released_a, 'YYYY-MM-DD') 
              - TO_DATE(project_started_milestone_a, 'YYYY-MM-DD')) AS rer_duration
          FROM projects_encoded
          WHERE real_estate_released_a IS NOT NULL
            AND project_started_milestone_a IS NOT NULL
          ),
          stats AS (
              SELECT
                  AVG(rer_duration) AS mean_dur,
                  STDDEV(rer_duration) AS std_dur
              FROM durations
          )
          SELECT d.fuze_project_id,
                d.site_name,
                d.rer_duration,
                CASE
                    WHEN d.rer_duration > s.mean_dur + 2 * s.std_dur THEN 'Extreme Delay'
                    WHEN d.rer_duration < s.mean_dur - 2 * s.std_dur THEN 'Unusually Fast'
                    ELSE 'Normal'
                END AS anomaly_flag
          FROM durations d
          CROSS JOIN stats s
          WHERE d.rer_duration IS NULL
            OR d.rer_duration > s.mean_dur + 2 * s.std_dur
            OR d.rer_duration < s.mean_dur - 2 * s.std_dur;
        </SQL Output>
    </Examples>
  expected_output: >
    <Output Format>
      SELECT t1.column1, t2.column2, SUM(t1.amount) AS total
      FROM table1 t1
      JOIN table2 t2 ON t1.id = t2.ref_id
      WHERE t1.status = 'active'
      GROUP BY t1.column1, t2.column2
      ORDER BY total DESC;
    </Output Format>
  agent: query_generation_agent
  context:
    - query_interpretation_task
  output_file: sql_query.sql